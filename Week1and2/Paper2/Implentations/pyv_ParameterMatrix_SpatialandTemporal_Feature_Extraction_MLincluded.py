# -*- coding: utf-8 -*-
"""ResearchPaper2_BCIWeek1

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Pj4KCphA26GJpFan6CyssiFWMZK_yWSB
"""

from google.colab import drive
drive.mount('/content/drive')

!pip install pywavelets tqdm scikit-learn seaborn

import numpy as np
import scipy.io as sio
import pywt
from scipy.signal import medfilt, resample
import matplotlib.pyplot as plt
from typing import Dict, List, Tuple, Optional, Any
import os
import glob
from tqdm import tqdm
import pandas as pd
from sklearn.preprocessing import StandardScaler
from sklearn.svm import SVC
from sklearn.ensemble import RandomForestClassifier
from sklearn.linear_model import LogisticRegression
from sklearn.gaussian_process import GaussianProcessClassifier
from sklearn.metrics import accuracy_score, confusion_matrix
from multiprocessing import Pool, cpu_count
import random
import warnings
import gc
import joblib
from concurrent.futures import ProcessPoolExecutor, ThreadPoolExecutor
from itertools import product
import time
import json

warnings.filterwarnings('ignore')

# Global debug flag
DEBUG_MODE = False

mat_dir = '/content/drive/MyDrive/BCI_Research_Week1/Datasets/AmericanKaggle/Patient_1'
patient_id = "Patient_1"

"""**What does sorted() do here?**

    sorted() sorts the list alphabetically by file path/name.
**What does glob.glob() do?**

    glob.glob(pattern) returns a list of all files/directories in your filesystem that match the pattern (using Unix shell-style wildcards like *, ?, etc).

    The list contains full file paths (relative or absolute, depending on your pattern).
**Example**

Suppose you have a directory /data/ with these files:

Patient_1_interictal_segment_0003.mat

Patient_1_interictal_segment_0001.mat

Patient_1_interictal_segment_0002.mat

Patient_1_preictal_segment_0001.mat

interictal_file list will look like:
   *
```
[
  "/content/drive/MyDrive/Dataset/Dog_4_interictal_segment_0001.mat",
  "/content/drive/MyDrive/Dataset/Dog_4_interictal_segment_0002.mat",
  ...
]


"""

interictal_files = sorted(glob.glob(os.path.join(mat_dir, f"{patient_id}_interictal_segment_*.mat")))
preictal_files = sorted(glob.glob(os.path.join(mat_dir, f"{patient_id}_preictal_segment_*.mat")))

print(f"Found {len(interictal_files)} interictal files")
print(f"Found {len(preictal_files)} preictal files")

"""**What does basename() do ?**

f = "/content/drive/MyDrive/BCI_Research_Week1/Datasets/Article1_IntracranialEEG/Patient_1/"

gets the basename of a dir
so ouput here would be : Patient_1

"""

print("\nFirst5 interictal files:")
for f in interictal_files[:5]:
  print(f" {os.path.basename(f)}")

print("\nFirst 5 preictal files:")
for f in preictal_files[:5]:
    print(f"  {os.path.basename(f)}")

"""#Refer to

###        Translating to .mat EEG Signals in Python

   ***in Python Syntax Relevant to Code Report***
"""

def inspect_mat(filepath : str):
  mat_data = sio.loadmat(filepath)
  print(mat_data)
inspect_mat(os.path.join(mat_dir,'Patient_1_interictal_segment_0002.mat'))

import os
import numpy as np
import matplotlib.pyplot as plt
from scipy.io import loadmat
from scipy.signal import decimate

# ─── SETTINGS ────────────────────────────────────────────────────────────────
target_fs   = 500   # down-sample to 500 Hz
pre_fn  = "Patient_1_preictal_segment_0017.mat"
int_fn  = "Patient_1_interictal_segment_0017.mat"

def load_segment(fn):
    data = loadmat(f"{mat_dir}/{fn}", struct_as_record=False, squeeze_me=True)
    key  = next(k for k in data if not k.startswith("__"))
    s    = data[key]
    sig  = s.data      # shape (n_ch, n_samps)
    fs   = float(s.sampling_frequency)
    # down‑sample each channel
    factor = int(round(fs/target_fs))
    return decimate(sig, factor, axis=1, zero_phase=True), target_fs

# load & down‑sample
pre_sig,  fs_ds = load_segment(pre_fn)
int_sig,  fs_ds = load_segment(int_fn)
n_ch, n_samps  = pre_sig.shape
t = np.arange(n_samps)/fs_ds  # seconds

# ─── PLOT ───────────────────────────────────────────────────────────────────
fig, axes = plt.subplots(n_ch, 2, figsize=(12, 2*n_ch), sharex=True)
for ch in range(n_ch):
    axes[ch,0].plot(t, pre_sig[ch], lw=0.5)
    axes[ch,0].set_ylabel(f"Ch {ch}")
    if ch==0: axes[ch,0].set_title("Pre‑ictal")
    axes[ch,1].plot(t, int_sig[ch], lw=0.5, color='C1')
    if ch==0: axes[ch,1].set_title("Inter‑ictal")

axes[-1,0].set_xlabel("Time (s)")
axes[-1,1].set_xlabel("Time (s)")
fig.tight_layout()
plt.show()

import os
import numpy as np
import matplotlib.pyplot as plt
from scipy.io import loadmat
from scipy.signal import decimate

# ─── SETTINGS ─────────────────────────────────────────────────────────────────
target_fs   = 500   # Hz after down‑sampling

# the three “sequence‑6” files for each of the 3 seizures:
seqs = ["0005","0006","0011", "0012","0017", "0018"]
files = []
for seq in seqs:
    fn = f"Patient_1_preictal_segment_{seq}.mat"
    path = os.path.join(mat_dir, fn)
    if os.path.exists(path):
        files.append(path)
    else:
        raise FileNotFoundError(f"Expected {fn} in {data_dir}")

# ─── LOAD & DOWNSAMPLE ALL THREE ──────────────────────────────────────────────
data_ds = []
for path in files:
    mat = loadmat(path, struct_as_record=False, squeeze_me=True)
    key = next(k for k in mat if not k.startswith("__"))
    s   = mat[key]
    eeg = s.data            # shape (n_ch, n_samps)
    fs  = float(s.sampling_frequency)

    factor = int(round(fs/target_fs))
    #Downsampled Signal down to sampling_frequency
    dsig   = decimate(eeg, factor, axis=1, zero_phase=True)
    data_ds.append(dsig)

# ─── PLOT GRID ────────────────────────────────────────────────────────────────
n_ch, n_samps = data_ds[0].shape
t = np.arange(n_samps) / target_fs

fig, axes = plt.subplots(n_ch, 6, figsize=(12, 2*n_ch), sharex=True, constrained_layout=True)
for col, dsig in enumerate(data_ds):
    for ch in range(n_ch):
        ax = axes[ch, col]
        # lw = linewidth = 0.5 so make the curve thin as to not seem as a block but see the curves
        ax.plot(t, dsig[ch], lw=0.5)
        if ch == 0:
            ax.set_title(f"Seg #{seqs[col]}", fontsize=12)
        if col == 0:
            ax.set_ylabel(f"Ch {ch}", fontsize=8)
        ax.tick_params(labelsize=6)

# common labels
axes[-1,0].set_xlabel("Time (s)", fontsize=8)
axes[-1,1].set_xlabel("Time (s)", fontsize=8)
axes[-1,2].set_xlabel("Time (s)", fontsize=8)
fig.suptitle("Pre‑ictal segments 5, 6, 11, 12 ,17 & 18 (all channels)", fontsize=14, y=1.02)
plt.show()

import os
import numpy as np
import matplotlib.pyplot as plt
from scipy.io import loadmat
from scipy.signal import decimate

# ─── CONFIG ──────────────────────────────────────────────────────────────────
target_fs   = 500     # Hz down‑sample rate
WS_min      = 10      # each segment is 10 min long
n_channels  = 15      # number of electrodes

# helper to load & downsample one .mat
def load_ds_segment(fn):
    m = loadmat(fn, struct_as_record=False, squeeze_me=True)
    key = next(k for k in m if not k.startswith("__"))
    s   = m[key]
    eeg = s.data                   # shape (15, orig_samps)
    fs  = float(s.sampling_frequency)
    factor = int(round(fs/target_fs))
    return decimate(eeg, factor, axis=1, zero_phase=True)

# the three seizure‐groups: segments 1–6, 7–12, 13–18
groups = [
    list(range(1,  7)),   # seq 1→6 = seizure 1
    list(range(7, 13)),   # seq 7→12 = seizure 2
    list(range(13,19)),   # seq 13→18 = seizure 3
]

for gi, seg_nums in enumerate(groups, start=1):
    # 1) load & ds each of the 6 segments for this group
    clips = []
    for seg in seg_nums:
        fn = f"Patient_1_preictal_segment_{seg:04d}.mat"
        path = os.path.join(mat_dir, fn)
        clips.append(load_ds_segment(path))
    # 2) concatenate along time
    full = np.concatenate(clips, axis=1)  # shape (15, n_samps_total)
    n_samps = full.shape[1]
    # 3) build time axis in minutes before seizure onset
    total_min = WS_min * len(seg_nums)
    t = np.linspace(-total_min, 0, n_samps)  # from -60…0 min for group 1, etc.

    # 4) plot all channels stacked
    fig, axes = plt.subplots(n_channels, 1, figsize=(12, 2*n_channels),
                             sharex=True, constrained_layout=True)
    for ch in range(n_channels):
        axes[ch].plot(t, full[ch], lw=0.5)
        axes[ch].set_ylabel(f"Ch {ch+1}", rotation=0, labelpad=10, fontsize=8)
        axes[ch].tick_params(labelsize=6)
        if ch == 0:
            axes[ch].set_title(f"Seizure {gi}: segments {seg_nums[0]}–{seg_nums[-1]}", fontsize=10)
    axes[-1].set_xlabel("Time before onset (minutes)", fontsize=9)

    # mark segment boundaries every 10 min
    for k in range(1, len(seg_nums)):
        axes[0].axvline(-total_min + k*WS_min, color='k', linestyle='--', alpha=0.4)
    # mark seizure onset at t=0
    axes[0].axvline(0, color='r', linestyle='-', lw=1)

    plt.show()

"""## Syntax Index:
I)`load_and_explore_segment(mat_file_example)`

*   To be clear:
    *   `data.shape` is **(channels, samples)**.

        For example, (16, 3000000):

        **16 rows**: 16 channels (electrodes)

        **3,000,000 columns**: 3 million samples (time points)

II)`data_length_sec = segment['data_length_sec'][0, 0][0, 0]`
         

*   Why all these `[0, 0]`?
    *   **MATLAB** often saves even scalars as arrays of arrays
    *   **Python mirrors this**: You often need `[0, 0]` (or more) to "unwrap" and reach the real value.
*   How to check what you need?
    *  Use `print(segment['sampling_frequency'])` to see its shape.
    * If it’s `array([[5000]])`, use `[0, 0]`.
    * If it’s `array([[array([[5000]])]])`, use `[0, 0][0, 0]`.
"""

def load_and_explore_segment(filepath: str):
  mat_data = sio.loadmat(filepath)
  segment_key = None
  for key in mat_data.keys():
    if 'segment' in key and not key.startswith('_'):
      segment_key = key
      break
  print(f"Loading: {os.path.basename(filepath)}")
  #segment_key = 'interictal_segment_N'
  #That is the key that hold the (1,1) outer array
  print(f"Segment key : {segment_key}")

  segment = mat_data[segment_key]

  # Extract data
  data = segment['data'][0, 0]
  print(data)
  sampling_freq = int(segment['sampling_frequency'][0, 0][0, 0])
  #II ---> in Index
  data_length_sec = segment['data_length_sec'][0, 0][0, 0]

  print(f"\nData shape: {data.shape}")
  print(f"Duration: {data_length_sec} seconds")
  print(f"Sampling frequency: {sampling_freq} Hz")
  print(f"Number of channels: {data.shape[0]}")
  print(f"Samples per channel: {data.shape[1]}")

  # Plot sample data
  plt.figure(figsize=(24, 6))
  #fig, axes = plt.subplots(n_ch, 2, figsize=(12, 2*n_ch), sharex=True)

  # Plot first 5 seconds of first channel
  time_to_plot = 600  # seconds
  samples_to_plot = time_to_plot * 256
  t = np.arange(samples_to_plot) / 256

  plt.subplot(2, 1, 1)
  plt.plot(t, data[0, :samples_to_plot])
  plt.title(f'Channel 1 - {os.path.basename(filepath)}')
  plt.xlabel('Time (s)')
  plt.ylabel('Amplitude')
  plt.grid(True)

  # Plot frequency spectrum
  plt.subplot(2, 1, 2)
  #Feed into a FFT numpy
  freqs = np.fft.fftfreq(samples_to_plot, 1/sampling_freq)
  #Get absolute values getting magnitude of each frequency
  fft_vals = np.abs(np.fft.fft(data[0, :samples_to_plot]))

  # Only plot positive frequencies up to 100 Hz
  pos_mask = (freqs > 0) & (freqs < 100)
  plt.plot(freqs[pos_mask], fft_vals[pos_mask])
  plt.title('Frequency Spectrum')
  plt.xlabel('Frequency (Hz)')
  plt.ylabel('Magnitude')
  plt.grid(True)

  plt.tight_layout()
  plt.show()

  return data, sampling_freq
mat_file_example1 = os.path.join(mat_dir,'Patient_1_interictal_segment_0043.mat')
#I -----> index
load_and_explore_segment(mat_file_example1)
#Second to start of Second Preictal timspan
mat_file_example2 = os.path.join(mat_dir,'Patient_1_preictal_segment_0008.mat')
load_and_explore_segment(mat_file_example2)
#End of Third Preictal timepsan
mat_file_example3 = os.path.join(mat_dir,"Patient_1_preictal_segment_0018.mat")
load_and_explore_segment(mat_file_example3)

"""1)`segment_data, params, fs, segment_idx, extractor = segment_tuple`
   * segment_tuple
     * Check Structure SYNTAX

2) **Imagine your sampling frequency (fs) is 10 Hz** (10 samples per second) and you have data for 1 second. The ch_segment array would have 10 numbers. For Example,

`ch_segment = [5.2, 8.1, 10.5, 7.0, 2.3, -1.4, -4.8, -3.1, 0.5, 4.9]`

**This is how you interpret it:**

    Index 0 (value 5.2) is the amplitude at Time = 0.0s

    Index 1 (value 8.1) is the amplitude at Time = 0.1s

    Index 2 (value 10.5) is the amplitude at Time = 0.2s

    ...and so on, until the last sample at Time = 0.9s.

Final Exmaple:

 I) **Input (segment_data)**:
```
          Time 1   Time 2   Time 3   ...
         -------------------------------
Channel 1 |  10µV  |  12µV  |  11µV  | ...
Channel 2 |   5µV  |   6µV  |   8µV  | ...
Channel 3 |  20µV  |  22µV  |  21µV  | ...
...       |  ...   |  ...   |  ...   | ...

```

II) Calculate Features for Each Channel

The code then loops through this table one row (one channel) at a time. For each channel, it performs the DWT and DESA calculations to get a 1D array of features.

**Intermediate Result (a list of feature arrays):**

```
'''
          Feature A | Feature B | Feature C | ...
         -----------------------------------------
Channel 1 |   1.5   |   0.8   |   2.3   | ...
Channel 2 |   1.7   |   0.9   |   2.1   | ...
Channel 3 |   1.3   |   0.7   |   2.5   | ...
...       |   ...   |   ...   |   ...   | ...

```
III)avg_features
```
# A list where each item is the feature array from one channel
channel_features = [
    [1.5, 0.8, 2.3],  # Features from Channel 1
    [1.7, 0.9, 2.1],  # Features from Channel 2
    [1.3, 0.7, 2.5]   # Features from Channel 3
]
```



The Averaging Operation (np.mean(..., axis=0))

The function then averages down the columns:
    First column average: (1.5 + 1.7 + 1.3) / 3 = 1.5
    Second column average: (0.8 + 0.9 + 0.7) / 3 = 0.8
    Third column average: (2.3 + 2.1 + 2.5) / 3 = 2.3

**After Averaging (The Final 1D Array)**

The final output is a **single 1D NumPy array** containing those averages:
Python

`avg_features = [1.5, 0.8, 2.3]`
"""

#A tuple is an ordered, immutable collection of items (e.g., (item1, item2, item3)).
def extract_features_for_segment(segment_tuple: Tuple) -> np.ndarray:
    """
    Extracts features for a single segment of EEG data.
    This function is designed to be called by a multiprocessing pool.
    """
    # Index --> I
    segment_data, params, fs, segment_idx, extractor = segment_tuple

    # number of channels
    n_channels = segment_data.shape[0]
    channel_features = []

    for ch in range(n_channels):
        # Index --> II
        #NumPy array slicing resulting in a 1D array
        ch_segment = segment_data[ch, :]
        #ProperSeizurePredictor instance extractor calls extract_segemnt_features method to perform WVT and
        features = extractor.extract_segment_features(
            ch_segment, params['mother_wavelet'], params['NL']
        )
        # Final Exmaple --> II
        channel_features.append(features)

    # Average features across all channels (spatial averaging)
    avg_features = np.mean(channel_features, axis=0)
    return avg_features

def create_feature_vectors(self: 'ProperSeizurePredictor', data: np.ndarray, params: Dict, fs: int) -> np.ndarray:
    """
    Creates feature vectors sequentially. This function is run inside a main
    worker process and should not have its own parallelism or progress bar.
    """
    # Windows Size wrt to fs time indexing
    window_samples = params['Ws'] * fs
    # Ne is the number of small segments that will be concatenated into one final feature vector.
    n_samples = data.shape[1]

    Ne = params['Ne']

    tasks_to_process = []
    # range(start, stop, step)
    '''
      SYNTAX
      1) step :window_samples * Ne (jump forward by the length of one full feature vector in each iteration).
      2) stop :n_samples - window_samples * Ne + 1 (stop before the signal ends, ensuring there's enough data for a full final feature vector).

    '''
    for start_idx in range(0, n_samples - window_samples * Ne + 1, window_samples * Ne):
        for seg_offset in range(Ne):
            #SYNTAX
            seg_start = start_idx + seg_offset * window_samples
            seg_end = seg_start + window_samples
            #Take all channels , seg_start:seg_end specifies the time window for the segment.
            segment_data = data[:, seg_start:seg_end]
            #task_to_progress list
            tasks_to_process.append((segment_data, params, fs, seg_start, self))
            #Final Example -->

    if not tasks_to_process:
        return np.array([])

    # Run tasks sequentially as a simple list comprehension.
    all_extracted_features = [extract_features_for_segment(task) for task in tasks_to_process]

    # Reconstruct the final feature vectors.
    all_feature_vectors = []
    num_final_vectors = len(all_extracted_features) // Ne
    for i in range(num_final_vectors):
        start_slice = i * Ne
        end_slice = start_slice + Ne
        feature_vector = np.concatenate(all_extracted_features[start_slice:end_slice])
        all_feature_vectors.append(feature_vector)

    return np.array(all_feature_vectors)


def debug_print(msg, level=1):
    """Print debug messages based on level"""
    if DEBUG_MODE and level <= 2:
        print(f"[DEBUG] {msg}")

"""## Syntax Index:
I)`random.seed(N)`

*   **To be clear**:
    *   ```
    import random
        random.seed(99)
        print([random.randint(0, 10) for _ in range(4)])  
          ```
        ### Always: [2, 7, 7, 6]
        *seed helps reproduce the same sequence of random numbers*

II)`self.seizure_data`

*   It’s a member variable of the **ImprovedPatientSpecificSeizurePredictorCV object** that contains an *instance* of the **ImprovedSeizureData class**.
* What does `self` do here?   
    *   `self` refers to this instance of the class.
    *   When you write `self.seizure_data`, you’re saying “store this object as a property on myself (this pipeline object), so I can use it in all my methods.”
    * so `self.var = A()` in B class ---> `self.var.functionofA()` ***to access function of A in B***
* Some self() examples /tips
    ```
    def __init__(self):
        self.var = A()
    def foo(self):
        self.var.some_a_function()      # CORRECT
        var.some_a_function()           # NameError: 'var' is not defined unless declared locally
    ```
    
* You Defined var as a Local Variable (not with self.)
  * If you write var = A() inside a method (not self.var = A()), then you can use var.some_a_function() inside that method only.
  * But this variable does not persist between methods—it’s just a temporary variable.
```
class B:
    def foo(self):
        var = A()
        var.some_a_function()   # works inside foo()
    
    def bar(self):
        var.some_a_function()   # NameError: var not defined in this scope
```
  * Can self. variables be used by other classes?
     * Only if you pass the object around.
     *  If you do **obj = MyClass()** and pass obj to another class, you can access its *self. variables* as **obj.x, obj.y, etc**.
     * ![image.png](data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAqUAAAEfCAYAAAB4Yb+8AAAgAElEQVR4Xu2dC9SVVZ3/N4gJKHij1iSG15EZsRmnohRELRuBpJHEC9bogNduqGil0ApHWoHWGrl1E7wwmokUiHkDi4pAtNFVTSPNoAJKaE15BxFE4N/3mfU7//3u97me99zPZ6/F0vec59n7tz9772d/92//9nO67f5LciQIQAACEIAABCAAAQjUkUA3RGkd6VM0BCAAAQhAAAIQgEBEAFFKR4AABCAAAQhAAAIQqDsBRGndmwADIAABCEAAAhCAAAQQpfQBCEAAAhCAAAQgAIG6E0CU1r0JMAACEIAABCAAAQhAAFFKH4AABCAAAQhAAAIQqDsBRGndmwADIAABCEAAAhCAAAQQpfQBCEAAAhCAAAQgAIG6E0CU1r0JMAACEIAABCAAAQhAAFFKH4AABCAAAQhAAAIQqDsBRGndmwADIAABCEAAAhCAAAQQpfQBCEAAAhCAAAQgAIG6E0CU1r0JMAACEIAABCAAAQhAAFFKH4AABCAAAQhAAAIQqDsBRGndm6C9DVi9erUbPnx4BwiTJ092kyZNygVm3LhxbtGiRR2uXbNmjRswYECu+7kIAhCAAAQgAIHGIFC2KH3llVfckiVL3L333uueeuop9/vf/z6q0cCBA93RRx/tPvzhD7tRo0a5d77znY1RU6xIJbBx40Y3aNCgsigtW7bMDRkypKx7EaVlYeMmCEAAAhCAQMsRKEuU3nfffe7qq68uCdEkKl0RKy1HusErhCht8AbCPAhAAAIQgECLEygsSuM8W4jS5u8liNLmb0NqAAEIQAACEGhmAoVF6VlnneWWLl2aq854SnNhaoiLEKUN0QwYAQEIQAACEGhbAoVE6QsvvBDFjIbpG9/4hhs/frzba6+93BtvvOEkcBYvXuz+8R//0X3wgx9sW7jNXvEFCxa4iy++uEM1ihxCylN/YkrzUOIaCEAAAhCAQOsTKCRKk7xpP/jBD9yIESMSacWJm3nz5rmxY8dG90yfPt1Nmzatw/2+l7VPnz6d8t68ebP77W9/67797W+7O++8M/r+tNNOc5/73OfcsGHD3Pbt292tt97qvv/977vf/OY3kZj+5Cc/GX0v8WypmnlLoD/++OPuxz/+sdOJ8OXLl5fKPeWUU9zpp58e2eTbk8Rq8ODBEaOFCxe6z3/+8+6b3/xmJyZPPPFEadEQt4AoKiiLitJy6pskSq+88sqo/e66665S+33iE59wn/nMZ9z+++9fqnve0/e//vWv3R133OF+8YtfuLVr17r3vOc97sQTT4z64Mknn9z6I50aQgACEIAABBqcQCFRqrqcdNJJ7le/+lWHammCnzBhgjvzzDNjT9tXQ5RKsFx44YVu9+7dHWzp1q1bJNxmzpzpJHj87/WdRMjcuXNTRWml8la9L7nkkk42WuGyR6fWZW/fvn2jj5OE4Pe+973IA60kcblp0yZ3++23d6i77FZ4hdJPfvITJxHnpxUrVrj3ve99ubtkUVFaTn3jROmXvvSl6BCd8gvbd+jQoR14ZYnSt99+O3q91E033RTbDmqD8847z82aNcv16NEjNxsuhAAEIAABCECgsgQKi1J5RS+44IJEKyQSdDL/4IMPLl1TDVEqMREKFl/sJX2na1auXOmOPfbY6PI4T2ml8o6rdxw4eQWvu+66RFEa2iNR+qEPfSjytPpJCwPzOM+ZMycSr5YkRuWpLSK8yhGl4XZ/Vn2LHJyzvL761a+6K664IvozS5TGeeHjbBI38SNBAAIQgAAEIFAfAoVFqcwMBU+c6bpGgkGpGqL0O9/5TrT1LW9hnJjQYSzFs1577bWRvX7yQwfiRGml8r7nnnvc+vXr3ciRI6OXuffu3du99dZb7rbbbnPyBlqSp1mhCBKMeYSsxOYXv/hFpxAA32utfH73u99F2Uqw/vSnPy2VUY7oKipKy6lvOaJUAlte3yxRKjbamvcXKOoL559/fnT/P/3TP5X4SPhv2LDBHXjggfUZiZQKAQhAAAIQaHMCZYlSMZOI0pantp6Tkm0nV0OU/vGPf3R77713tKUdvvRdgkzb3UmCeMaMGe6iiy6Kvo8TpZXKW/krtlUxratWrXLPPPNMtO0uQRR6cu1XiJJEqTh/9KMfdXvssYfr3r17ZPv8+fM7CXLFlfbr188deuihHZrF9w7n7fNFRWk59Y0TpRLXiiV973vf20k8mu2KCz3ooINSPaVxiydrW23r+7GpyvfBBx+M4pFJEIAABCAAAQjUnkDZotRM/fOf/xwdIJFHMkzmAfzhD3/Y6RR3JQ46qbw4UTpmzJhIsCWJUv/AT9JBp0rkrUNOn/3sZ6ODNUppIQVpotTflvcZ/+lPf3JHHHFEB+xaCEhs+fGkH/nIR6Jf3iqaiorScuqbFFP6la98pWRu6PXVF8YrbfteoQSqg5/kEbUUtoffJ4uy4noIQAACEIAABLpGoMui1Ir/7ne/G20ph0niQcIjjDVsdVEqsXzMMcd0EKKqs7yd2mLXmwL8lCZK08TSlClTnDy/liRg3/3ud3eIJ/VDKYp0lyKitNz65nklVJrwLPpdWv0RpUV6B9dCAAIQgAAEKkugsCiVF1InvBWv2b9//+h1Rtqi1kGdMHbTPFq//OUvOx2O8rfQy30llPJvVE9pKOj0ZgLFkirFnYwvV5QqblJvRLCkeEt5qH3PqF6HdOSRRxbuOUVEabn1zfKUaps9LXY2TZTqQNTXv/713PVGlOZGxYUQgAAEIACBihMoLErjtruTrLIDKXHCQ+81Vdzn1q1b3ejRozu9ZirPe0obWZTqBwWmTp3aQSwuWbIk+vvcc891jzzySAds5YpSZZL2K1virDcmlJOKiNJy65sUU3rfffdFoQl6B+2nP/3pDuZPnDixxDZNlCoPHYbzkw7G6UcddOhMSe9z/dGPfuTe//73R280IEEAAhCAAAQgUB8CVRWlenH9xz/+cffSSy91Onij6lp8X1ysZbOL0rhXZ6XVtyuiVKfedaI8LnXF+1dElJZb36TT92mxn/6hrTRRKi+rFgD+z+L6+fq8dI3eGUuCAAQgAAEIQKA+BKoiSrV9/LWvfa3DYZvZs2e7L3/5y7lr2eyi9PXXX48EefhDAwKgl7krZMFPXRGl+iUl/eKTXjgfpnXr1rl3vetdubn7FxYRpeXWt+grofTDBxKalrLeU/ryyy9HJ/R/9rOfpTLw+1tZsLgJAhCAAAQgAIEuESgsShWf+MADDzi9euipp54qCSH9jOfRRx/tPvaxj7nhw4d3et2OrNRrfvSzoHpFkpJOiGvrXoIsjP1rdlGq+v3hD3+IYm3tZ1A/9alPRT8RKgEnRpUSpcpHv2Dln1jXZ/Kefutb3yq7gxQRpeXWNymmVK/50psE7H2kYqefGP37v//7DvXJEqW6eMeOHVEcr+Js1W/tbQjWZ/UuU8X82q9qlQ2MGyEAAQhAAAIQKJtAYVFadkncWFUCcaJU8ZPhT41W1QgyhwAEIAABCEAAAmUSQJSWCa6RbtMPGYwdO7bD9r1CKPTeUP3AAAkCEIAABCAAAQg0OgFEaaO3UIJ9ikn141LDw2Ll/Kxok6LAbAhAAAIQgAAEWoAAorRJGzHu3a5WFZ0i12l4YiSbtHExGwIQgAAEINCGBBClTdroSaJU2/Z672Y5L8tvUhSYDQEIQAACEIBACxBAlDZpIy5evNjpINPy5cujGhx77LFu5MiR0YvmDzjggCatFWZDAAIQgAAEINCuBBCl7dry1BsCEIAABCAAAQg0EAFEaQM1BqZAAAIQgAAEIACBdiWAKG3XlqfeEIAABCAAAQhAoIEIIEobqDEwBQIQgAAEIAABCLQrAURpu7Y89YYABCAAAQhAAAINRABR2kCNgSkQgAAEIAABCECgXQkgStu15ak3BCAAAQhAAAIQaCACiNIGagxMgQAEIAABCEAAAu1KAFHari1PvSEAAQhAAAIQgEADEUCUNlBjYAoEIAABCEAAAhBoVwKI0nZteeoNAQhAAAIQgAAEGogAorSBGgNTIAABCEAAAhCAQLsSQJS2a8tTbwhAAAIQgAAEINBABBClDdQYmAIBCEAAAhCAAATalQCitF1bnnpDAAIQgAAEIACBBiKAKG2gxsAUCEAAAhCAAAQg0K4EEKXt2vLUGwIQgAAEIAABCDQQAURpAzUGpkAAAhCAAAQgAIF2JYAobdeWp94QgAAEIAABCECggQggShuoMTAFAhCAAAQgAAEItCsBRGm7tnyBem/evNlt3769wB21v7Rnz55un332qX3BlAgBCEAAAhCAQEUIIEorgrF1M9myZYvbtm1bU1SwV69ebu+9924KWzESAhCAAAQgAIGOBBCl9IhUAi+++GLTEOrWrZs78MADm8ZeDIUABCAAAQhA4P8TKCRKx40b5zZs2OBWrFhRymHt2rXuAx/4gJswYYKbNm1a6fObb77ZTZw40f3xj390s2fPjr7TNjCpuQg0kygV2X79+jUXYKyFAAQgAAEIQCAiUEiUmtBcs2aNGzBgQJTBggUL3MUXX+ze8573uN/+9reuR48e0ef6TGnevHlu+vTpiNIm7XCI0iZtOMyGAAQgAAEINBmBQqL0N7/5jRs2bJi755573Ec/+tGoqldccYXbtGmTW7ZsmXviiSfcwIED3RtvvOH+6q/+ys2YMcNddNFFHUTprl27Soi6d+/eZLjaz9xKitLHH3/cnX322RFE9Y3Ro0d3Ajpr1iw3c+bM1GvSWqGVPaXaqVi0aFGH6mvRN3bs2IbqmBs3bnSDBg2KFqSNZltDgcKYhiCwevVqN3z4cPf973/fffzjHy/ZNHnyZDdnzpzSvKYv/Lnt1FNPrXo/N6eP7whqCGgYAYEqESgkSt9++233d3/3d278+PHui1/8YmmA3nHHHe68884rTUImXleuXOmOPfbYkih97LHH3Gc+8xmn75XHv/3bv5U8q7p26tSpTtccd9xx7oYbbnDve9/7omr36dPHfelLX4rK+9a3vuU0QPfbbz/39a9/3S1evDi65owzznD/+q//WsrPeD3zzDPuH/7hH9ztt9/uPvGJT0Qf/+lPf3JHHHFE6TOVrXwfeOCByOOrvFRe3759XdwEm+dB8fOf/9x97Wtfi+ojoT5//nx3zDHHuO985zvRw08M9Pm1115behCaR1n3fPrTn46uufzyy2PrpXpIpCgpb6XQ1ldeecVNmjTJ3XnnndH3X/jCF6LylNJ4+32tkqLU8l2yZEn0v6Eoff755931118fTQTlplYXpWrTK6+8soTn0EMPdYcccki5uKpyH6K0KljJtEoETGhKhOp5qWRz3e9///sOi6v/+I//cKeccopbvnx55Hjp6uJLY/nggw/uMKb9auaZa6qEhWwhUBcChUSpLNTAlSi89957I9Ekz+mzzz7rvvrVr7revXtH2/QSQRJktp1vYuv88893V111lXvooYfcNddcU1qZ2kpV3jMJR3nLfvjDHzoJu3e9612RKFV68MEHo/L0wJC41eQnkffaa6+5T33qU9Fnim0N01lnnRXlI+GppIEuASzP3X/+539Gq+QpU6a4MWPGuKeeeip6QAwdOjR6GJUjSn/wgx+4Cy64oEOe73znO9373//+qN6XXHKJ22uvvSKxKVtsFWycPve5z0X1kHjzOYX1yhKl8mL/+te/drfddlt06/e+973IpizefjlJolS2KWbYkmKNLWV5O5NEqdpDtkmIl5taXZSKiy1CymVU7fsQpdUmTP6VJqBnpZ5hmteUbG7T3HDUUUeVzkv4ZyVeeumlLotSzW2+GA7rhSitdEuTX6MTKCxKbZBIiGobf9WqVdEkaUJPQlQeOROoAmBiy8RXuDJV/Ok73vGOkmjUYJcH6NZbb3USlBq4F154YWlb11arOnBl3lR51yRQf/e733ViLjsliNetWxeJU4k5eXD1IFLZr776qpOQtGTXKxxBrxkK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)
* Why 6?
   * In many public epilepsy datasets (**like the American Epilepsy Kaggle dataset**), each seizure event is split into multiple smaller preictal files—often of fixed length (e.g., **10 minutes each**).

  * In this dataset, for each seizure there are typically 6 preictal segments, which together cover the preictal period (e.g., the hour before a seizure: 6 × 10min = 60min).

"""

class SeizureData:
  #Feature extraction pipeline for EEG seizure prediction.
  def __init__(self, patient_id: str, data_dir: str, random_seed: int = 42):
        self.patient_id = patient_id
        self.data_dir = data_dir
        self.random_seed = random_seed

        # Set seeds
        random.seed(random_seed)
        np.random.seed(random_seed)

        print(f"Initializing seizure data for {patient_id}...")
        self.seizure_records = self._organize_seizure_records()
        self._validate_data()
  # in python _function the underscore indicates
  def _load_mat_file(self, filepath: str, target_fs: int = 256) -> Tuple[np.ndarray, int]:
        """Load and preprocess a single .mat file"""
        try:
            mat_data = sio.loadmat(filepath)

            segment_key = None
            for key in mat_data.keys():
                if 'segment' in key and not key.startswith('_'):
                    segment_key = key
                    break

            if segment_key is None:
                return None, None

            segment = mat_data[segment_key]
            data = segment['data'][0, 0].astype(np.float32)
            original_fs = int(segment['sampling_frequency'][0, 0][0, 0])

            if original_fs > target_fs:
                num_samples = int(data.shape[1] * (target_fs / original_fs))
                data = resample(data, num_samples, axis=1)
                fs = target_fs
            else:
                fs = original_fs

            data = data - np.mean(data, axis=1, keepdims=True)
            channel_stds = np.std(data, axis=1, keepdims=True)
            channel_stds[channel_stds < 1e-6] = 1.0
            data = data / channel_stds

            return data, fs

        except Exception as e:
            print(f"Error loading {filepath}: {e}")
            return None, None
  "Predicate data last two segments concatinated in seizure data"
  def _organize_seizure_records(self) -> List[Dict]:
        """Organize files into seizure records"""
        interictal_files = sorted(glob.glob(os.path.join(self.data_dir, f"{self.patient_id}_interictal_*.mat")))
        preictal_files = sorted(glob.glob(os.path.join(self.data_dir, f"{self.patient_id}_preictal_*.mat")))

        print(f"Found {len(interictal_files)} interictal files")
        print(f"Found {len(preictal_files)} preictal files")

        # Load all files with progress bar
        print("Loading EEG files...")
        all_data = {}

        for f in tqdm(interictal_files + preictal_files, desc="Loading files"):
            data, fs = self._load_mat_file(f)
            if data is not None:
                all_data[f] = (data, fs)

        # Organize into seizures
        files_per_seizure = 6
        n_seizures = max(1, len(preictal_files) // files_per_seizure)

        seizure_records = []

        for i in range(n_seizures):

            # 0 * 6 = 0 , 1 * 6 = 6 , 2 * 6 = 12
            start_idx = i * files_per_seizure
            end_idx = min((i + 1) * files_per_seizure, len(preictal_files))

            # Get last 2 preictal files for this seizure 20 mins
            seizure_files = preictal_files[start_idx:end_idx]
            if len(seizure_files) >= 2:
                seizure_files = seizure_files[-2:]

            # Load and concatenate preictal
            preictal_arrays = []
            fs = None
            for f in seizure_files:
                if f in all_data:
                    data, file_fs = all_data[f]
                    preictal_arrays.append(data)
                    fs = file_fs

            if preictal_arrays:
                # 2D numpy array rows number of ch , columns , timepoint samples
                preictal_data = np.concatenate(preictal_arrays, axis=1)

                # Random interictal selection
                n_inter = min(random.randint(2, 4), len(interictal_files))
                selected_inter = random.sample(interictal_files, n_inter)

                interictal_list = []
                for f in selected_inter:
                    if f in all_data:
                        data, _ = all_data[f]
                        interictal_list.append(data)

                if interictal_list:
                    seizure_records.append({
                        'seizure_id': i,
                        'preictal_data': preictal_data,
                        'preictal_fs': fs,
                        'interictal_data': interictal_list,
                        'interictal_fs': fs
                    })

        return seizure_records
  #ChatGPT validate
  def _validate_data(self):
        """Validate loaded data quality"""
        print(f"\nValidating {len(self.seizure_records)} seizure records...")

        for i, record in enumerate(self.seizure_records):
            pre_shape = record['preictal_data'].shape
            pre_duration = pre_shape[1] / record['preictal_fs']

            print(f"Seizure {i}: {pre_duration:.1f}s preictal, {len(record['interictal_data'])} interictal files")

            if np.any(np.isnan(record['preictal_data'])):
                print(f"  WARNING: NaN values in preictal data!")

            channel_vars = np.var(record['preictal_data'], axis=1)
            if np.any(channel_vars < 1e-6):
                print(f"  WARNING: Low variance channels detected!")

"""I)Why *`*.extend()*`* is Used

The goal is to create a single, flat list of features.

   *  `list.append([item1, item2])` would add the list itself as one element, creating a nested list like `[[1.5, 0.8], [1.7, 0.9]]`.

   *  `list.extend([item1, item2])` adds the individual elements from the given list, creating the desired flat list like `[1.5, 0.8, 1.7, 0.9]`.
"""

class ProperSeizurePredictor:
    """Seizure predictor with proper DESA and wavelet implementations"""

    def __init__(self, patient_id: str, data_dir: str, n_jobs: int = -1, random_seed: int = 42):
        self.patient_id = patient_id
        self.data_dir = data_dir
        self.n_jobs = n_jobs if n_jobs > 0 else cpu_count()
        self.random_seed = random_seed

        print(f"Initializing predictor with {self.n_jobs} cores")

        self.seizure_data = SeizureData(patient_id, data_dir, random_seed)

        self.param_grid = {
            'NL': [5, 7, 9],
            'L': [10, 20],
            'Ws': [5, 10, 15, 20],
            'mother_wavelet': ['db6', 'coif1', 'sym3', 'bior2.6'],
            'Ne': [6],
            'classifier': ['SVM', 'RF', 'Logistic', 'Gaussian']
        }

        self.best_params = None
        self.results_history = []
        # --- REMOVED Manager and shared progress bar to fix the error and simplify ---
    #Chat Help
    '''
     mathematical engine for the DESA algorithm
     unlike other methods that average over a window, the TKEO provides an instantaneous measure, making
     it excellent at detecting rapid changes in both a wave's strength (amplitude) and its oscillation speed (frequency).
    '''
    def _teager_kaiser_operator(self, x: np.ndarray) -> np.ndarray:
        if len(x) < 3: return np.array([])
        #single 1D NumPy array
        return x[1:-1]**2 - x[:-2] * x[2:]
    #Chat Help
    def _desa_algorithm(self, x: np.ndarray) -> Tuple[np.ndarray, np.ndarray]:
        if len(x) < 4: return np.array([]), np.array([])

        y = np.diff(x)
        psi_x = self._teager_kaiser_operator(x)
        psi_y = self._teager_kaiser_operator(y)

        if len(psi_x) == 0 or len(psi_y) == 0: return np.array([]), np.array([])

        n_points = min(len(psi_x), len(psi_y) - 1)
        if n_points <= 0: return np.array([]), np.array([])

        psi_x_sliced, psi_y_sliced, psi_y_next_sliced = psi_x[:n_points], psi_y[:n_points], psi_y[1:n_points + 1]
        omega, amplitude = np.zeros(n_points), np.zeros(n_points)
        denom = 4 * psi_x_sliced
        safe_denom_mask = np.abs(denom) > 1e-10
        arg = np.ones(n_points)
        arg[safe_denom_mask] = 1 - (psi_y_sliced[safe_denom_mask] + psi_y_next_sliced[safe_denom_mask]) / denom[safe_denom_mask]
        omega = np.arccos(np.clip(arg, -1, 1))
        sin_omega = np.sin(omega)
        safe_sin_mask = np.abs(sin_omega) > 1e-10
        safe_mask = safe_denom_mask & safe_sin_mask
        amplitude[safe_mask] = np.sqrt(np.abs(psi_x_sliced[safe_mask] / (sin_omega[safe_mask]**2)))
        #smooths need to plot msall window slide
        #The raw amplitude and omega arrays calculated by DESA can have sharp, single-point spikes that are just noise
        if len(omega) > 5:
            omega = medfilt(omega, kernel_size=5)
            amplitude = medfilt(amplitude, kernel_size=5)

        return amplitude, omega
    #wavelet param
    def extract_segment_features(self, segment: np.ndarray, wavelet: str, levels: int) -> np.ndarray:
        features = []
        #This is a safety check. np.std() calculates the standard deviation. If the standard deviation is zero (meaning the signal is a flat line), dividing by it would cause an error.
        if np.std(segment) > 0:
            #Z-score standardization
            segment = (segment - np.mean(segment)) / np.std(segment)

        try:
           #It returns a list of coefficient arrays (coeffs).
            coeffs = pywt.wavedec(segment, wavelet, level=levels)
            #Jumps to D level coeffs
            for i in range(1, levels + 1):
                if i <= len(coeffs) - 1:
                    detail = coeffs[len(coeffs) - i]
                    #amplitude and freqeuncy of one level
                    amplitude, frequency = self._desa_algorithm(detail)
                    features.extend([np.mean(amplitude) if len(amplitude) > 0 else 0, np.mean(frequency) if len(frequency) > 0 else 0])
                else: features.extend([0, 0])
            #Goes back to Aproximation
            if len(coeffs) > 0:
                approx = coeffs[0]
                # tuple unpacking
                amplitude, frequency = self._desa_algorithm(approx)
                # Index --> I
                features.extend([np.mean(amplitude) if len(amplitude) > 0 else 0, np.mean(frequency) if len(frequency) > 0 else 0])
            else: features.extend([0, 0])
        except Exception as e:
            debug_print(f"Feature extraction error: {e}", level=2)
            features = [0] * (2 * (levels + 1))
        return np.array(features)

    def extract_features_for_seizure(self, seizure_record: Dict, params: Dict) -> Tuple[np.ndarray, np.ndarray]:
        all_features, all_labels = [], []
        L_samples = params['L'] * 60 * seizure_record['preictal_fs']

        preictal_data = seizure_record['preictal_data']
        if preictal_data.shape[1] > L_samples:
            preictal_data = preictal_data[:, -L_samples:]

        features = create_feature_vectors(self, preictal_data, params, seizure_record['preictal_fs'])
        if len(features) > 0:
            all_features.append(features)
            all_labels.extend([1] * len(features))

        for i, inter_data in enumerate(seizure_record['interictal_data']):
            if inter_data.shape[1] > L_samples:
                inter_data = inter_data[:, -L_samples:]

            features = create_feature_vectors(self, inter_data, params, seizure_record['interictal_fs'])
            if len(features) > 0:
                all_features.append(features)
                all_labels.extend([0] * len(features))

        return (np.vstack(all_features), np.array(all_labels)) if all_features else (np.array([]), np.array([]))

    def evaluate_single_fold(self, train_seizures: List[Dict], test_seizure: Dict, params: Dict, verbose: bool = False) -> Optional[Dict]:
        X_train_list, y_train_list = [], []
        for seizure in train_seizures:
            X, y = self.extract_features_for_seizure(seizure, params)
            if len(X) > 0:
                X_train_list.append(X)
                y_train_list.append(y)

        if not X_train_list: return None

        X_train, y_train = np.vstack(X_train_list), np.hstack(y_train_list)
        X_test, y_test = self.extract_features_for_seizure(test_seizure, params)

        if len(X_test) == 0: return None

        scaler = StandardScaler()
        X_train_scaled = scaler.fit_transform(X_train)
        X_test_scaled = scaler.transform(X_test)

        clf_name = params['classifier']
        if clf_name == 'SVM': clf = SVC(kernel='rbf', probability=True, random_state=self.random_seed)
        elif clf_name == 'RF': clf = RandomForestClassifier(n_estimators=100, random_state=self.random_seed)
        elif clf_name == 'Logistic': clf = LogisticRegression(max_iter=1000, random_state=self.random_seed)
        else: clf = GaussianProcessClassifier(random_state=self.random_seed)

        clf.fit(X_train_scaled, y_train)
        y_pred = clf.predict(X_test_scaled)
        cm = confusion_matrix(y_test, y_pred)

        if cm.shape == (2, 2):
            tn, fp, fn, tp = cm.ravel()
            accuracy = (tp + tn) / (tp + tn + fp + fn) if (tp + tn + fp + fn) > 0 else 0
            sensitivity = tp / (tp + fn) if (tp + fn) > 0 else 0
            false_alarm = fp / (fp + tn) if (fp + tn) > 0 else 0
        else:
            accuracy, sensitivity, false_alarm = accuracy_score(y_test, y_pred), 0, 0

        best_k = self._find_best_k(y_test, y_pred, params['L'])

        return {'accuracy': accuracy, 'sensitivity': sensitivity, 'false_alarm_rate': false_alarm, 'K': best_k, 'confusion_matrix': cm.tolist()}

    def _find_best_k(self, y_true: np.ndarray, y_pred: np.ndarray, L: int) -> int:
        if len(y_pred) < L: return int(L * 0.6) if L > 0 else 1
        best_k, best_acc = 1, 0
        for k in range(1, L + 1):
            correct, total = 0, 0
            for i in range(len(y_pred) - L + 1):
                window_true, window_pred = y_true[i:i+L], y_pred[i:i+L]
                if np.sum(window_pred) >= k:
                    if np.any(window_true == 1): correct += 1
                elif np.all(window_true == 0): correct += 1
                total += 1
            if total > 0:
                acc = correct / total
                if acc > best_acc: best_acc, best_k = acc, k
        return best_k

    def evaluate_parameters(self, params_tuple: Tuple, verbose: bool = False) -> Optional[Dict]:
        NL, L, Ws, wavelet, Ne, clf_name = params_tuple
        params = {'NL': NL, 'L': L, 'Ws': Ws, 'mother_wavelet': wavelet, 'Ne': Ne, 'classifier': clf_name}

        seizures = self.seizure_data.seizure_records
        fold_results = [res for s in seizures if (res := self.evaluate_single_fold([seizure for seizure in seizures if seizure['seizure_id'] != s['seizure_id']], s, params, verbose)) is not None]

        if not fold_results: return None

        return {
            'params': params,
            'accuracy': np.mean([r['accuracy'] for r in fold_results]), 'accuracy_std': np.std([r['accuracy'] for r in fold_results]),
            'sensitivity': np.mean([r['sensitivity'] for r in fold_results]), 'sensitivity_std': np.std([r['sensitivity'] for r in fold_results]),
            'false_alarm_rate': np.mean([r['false_alarm_rate'] for r in fold_results]), 'false_alarm_std': np.std([r['false_alarm_rate'] for r in fold_results]),
            'K': int(np.mean([r['K'] for r in fold_results])), 'n_folds': len(fold_results)
        }

    def optimize_parameters(self, n_jobs: int = None):
        """Run full parameter optimization with a single, clean progress bar."""
        if n_jobs is None: n_jobs = self.n_jobs

        param_combinations = list(product(
            self.param_grid['NL'], self.param_grid['L'], self.param_grid['Ws'],
            self.param_grid['mother_wavelet'], self.param_grid['Ne'], self.param_grid['classifier']
        ))

        # --- CORRECTED: Inform the user of the workload, then show one clean progress bar. ---
        n_seizures = len(self.seizure_data.seizure_records)
        total_folds = len(param_combinations) * n_seizures
        print(f"\n💡 Patient has {n_seizures} seizure records for leave-one-out CV.")
        print(f"Total parameter combinations to test: {len(param_combinations)}")
        print(f"Total cross-validation folds to process: {total_folds}")
        print(f"Using {n_jobs} processes.")

        start_time = time.time()

        with ProcessPoolExecutor(max_workers=n_jobs) as executor:
            # This is the single, clean progress bar for the entire job.
            results = list(tqdm(
                executor.map(self.evaluate_parameters, param_combinations),
                total=len(param_combinations),
                desc="🚀 Evaluating Parameters"
            ))

        results = [r for r in results if r is not None]

        elapsed_time = time.time() - start_time
        print(f"\nOptimization completed in {elapsed_time:.1f} seconds")
        print(f"Valid results: {len(results)}/{len(param_combinations)}")

        if not results:
            print("No valid results!")
            return None

        results_df = pd.DataFrame([
            {
                'NL': r['params']['NL'], 'L': r['params']['L'], 'Ws': r['params']['Ws'],
                'wavelet': r['params']['mother_wavelet'], 'classifier': r['params']['classifier'],
                'accuracy': r['accuracy'], 'accuracy_std': r['accuracy_std'],
                'sensitivity': r['sensitivity'], 'false_alarm_rate': r['false_alarm_rate'], 'K': r['K']
            } for r in results
        ])

        if results_df.empty:
            print("No valid results after processing.")
            return None

        best_idx = results_df['accuracy'].idxmax()
        self.best_params = results[best_idx]['params']

        print("\n" + "="*80)
        print("TOP 10 PARAMETER COMBINATIONS:")
        print("="*80)
        print(results_df.nlargest(10, 'accuracy').to_string(index=False))

        print("\n" + "="*80)
        print(f"BEST PARAMETERS for {self.patient_id}:")
        print("="*80)
        for key, value in self.best_params.items():
            print(f"  {key}: {value}")

        best_result = results[best_idx]
        print(f"\nPerformance:")
        print(f"  Accuracy: {best_result['accuracy']:.1%} ± {best_result['accuracy_std']:.1%}")
        print(f"  Sensitivity: {best_result['sensitivity']:.1%}")
        print(f"  False Alarm: {best_result['false_alarm_rate']:.1%}")

        return results_df

def run_complete_pipeline(patient_id: str, data_dir: str, mode: str = 'diagnostic'):
    """Run the complete pipeline"""
    print(f"\n{'='*80}\nEEG Seizure Prediction Pipeline - {mode.upper()} MODE\nPatient: {patient_id}\n{'='*80}\n")
    predictor = ProperSeizurePredictor(patient_id, data_dir, n_jobs=-1)

    if mode == 'diagnostic':
        # Diagnostic mode would need its own simplified run logic
        pass
    else:
        results_df = predictor.optimize_parameters()
        if results_df is not None:
            results_df.to_csv(f"{patient_id}_results.csv", index=False)
            print(f"\nResults saved to {patient_id}_results.csv")
            if predictor.best_params:
                with open(f"{patient_id}_best_params.json", 'w') as f:
                    json.dump(predictor.best_params, f, indent=2)
                print(f"Best parameters saved to {patient_id}_best_params.json")
        return predictor, results_df

if __name__ == "__main__":
    patient_id = "Patient_1"
    data_dir = "/content/drive/MyDrive/BCI_Research_Week1/Datasets/AmericanKaggle/Patient_1"

    if not os.path.isdir(data_dir):
        print(f"Error: Data directory not found at '{data_dir}'")
        print("Please update the 'data_dir' variable to the correct path.")
    else:
        predictor, results = run_complete_pipeline(
            patient_id=patient_id,
            data_dir=data_dir,
            mode='full'
        )

"""# Standardization
**Why is this useful?**
  * It removes arbitrary differences between channels due to placement or hardware, letting you compare patterns fairly.
  * Machine learning algorithms work better when all inputs are on similar scales.
  ![image.png](data:image/png;base64,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4I033nA77LBD0o+WL1/uxowZM6TQ119/3V144YXuu9/9rps8eXLH2l5oudrIj3/8Y3fNNde4Rx99NPn5K1/5ijv33HPbr2SBEsK+UOCR3FvUnyZOnOiWLFnixo8f72699VZ33333ucsvv9ytscYauc8XvUE+Oumkk9xRRx3l9thjj6KPcV+JCRQWpq+99po77bTTBquyySabuI033ritqt12223u+9//vvv5z3/eVjk8DIEqEZDA8vuTxNBdd93lnnrqKbfZZpvlVuXOO+90hx12mLvkkkvcwQcf7D74wQ/mPtPuDfbOE0880e29995JcZpIL7vssuT/e9GXuy1MNXFKCCxevHiYQGmF369+9St33nnnuSuvvDIpR+LnoIMOcnvuuac744wzWimKe7tM4N577x1swwceeKCzNmavVfueOXNmIqp23nln19fX15W2bu/5xje+4T71qU+5N9980z3xxBPu7LPPTkzR3LvhhhsOmYM7iaYXwvSiiy5y4q2xYq211hqx+eFYI9snTZrkxO6QQw4Zcbk8WB4ChYWpTO5UpMKqP3fuXDdnzpyeRXzKgx1LmkwgFFgWWVA0Yccdd8xFoyjltGnTohGe3IdHeIP6qiI5d9xxR7SEXvTlbgvTEaIZ9tho+KdTtjetHC20PvGJT7j3vve9TouvsH3H2nU32rra9gYbbJDMh7FLglgCecaMGV1xUS+EaacM7wb/TtlGOZ0h0LYwta0OrWJ0KTLw9a9/PQnV//Wvf3VqRIpAaKvkM5/5jPvOd77jFG0NtzPV6SZMmDAk9K/ywkaoDnrmmWcmUYgrrrgimZwVMdJ2S8yGzmCiFAh0joAvsN566y138cUXO22T33333YNbXA8//LCbPXt2Iga11f+tb33LbbfddoP9wayxyerll19O+oD1NW2zn3POOclWtd+PbrrppmRbWakDSsWRiFI/evrpp5Ot+QsuuCDpn+FlEZ177rlnWMpBrC9rAtVuiN6nsvv7+5No5H777ZcUbRPtRz/60cTu973vfUN+99MVdP/JJ5/sFInUZQvkvPLDceLd7353EoG65ZZb3DbbbJNEn7S1blv5vqDUe4ydz+Laa69NojJp77bxyp6x7d9QWOT5K49P51pjc0t65ZVX3KabburU13QplUb/r7ahK2zXaifqX35am9//NO/deOONSVs/5phj3PHH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)




# What Do the Different Levels (A,D1, D2, D3) Mean?

The Wavelet Transform is powerful because it finds these "details" at different scales.
   * Approximation Coefficients (cA): These represent the large, slow hills and valleys you drive over. They are the main, low-frequency trend of the road.

* Detail Coefficients (cD): These represent the small bumps, cracks, and potholes in the road surface. They are the high-frequency vibrations you feel, but they don't change your overall elevation very much.
   * cD1 (Highest Frequency): These are the tiniest, fastest vibrations, like the fine texture of the road's asphalt.

   * cD2: These are slightly larger bumps and dips.

   * cD3: These are even larger bumps that are still considered "details" compared to the main hills.

In EEG analysis, specific brain rhythms like **gamma waves are high-frequency and are captured in these detail coefficients**. By calculating features from each level of detail coefficients, the algorithm can quantify the "amount of wiggliness" at different frequencies, which is a powerful way to detect the subtle changes that occur before a seizure
"""

import numpy as np
import matplotlib.pyplot as plt
import pywt
import scipy.io as sio
from scipy.signal import medfilt

# --- Load Multi-Channel Data ---
try:
    filepath = '/content/drive/MyDrive/BCI_Research_Week1/Datasets/AmericanKaggle/Patient_1/Patient_1_test_segment_0027.mat'
    mat_data = sio.loadmat(filepath)
    segment_key = [key for key in mat_data if 'segment' in key and not key.startswith("_")][0]
    segment = mat_data[segment_key]
    multi_channel_signal = segment['data'][0,0]
    sampling_freq = int(segment['sampling_frequency'][0, 0][0, 0])
except FileNotFoundError:
    print("File not found. Using randomly generated data for demonstration.")
    multi_channel_signal = np.random.randn(16, 2000)
    sampling_freq = 400

# --- Functions needed for DESA (copied from the main script for this demonstration) ---
def _teager_kaiser_operator(x: np.ndarray) -> np.ndarray:
    if len(x) < 3: return np.array([])
    return x[1:-1]**2 - x[:-2] * x[2:]

def _desa_algorithm(x: np.ndarray) -> tuple[np.ndarray, np.ndarray]:
    if len(x) < 4: return np.array([]), np.array([])
    y = np.diff(x)
    psi_x = _teager_kaiser_operator(x)
    psi_y = _teager_kaiser_operator(y)
    if len(psi_x) == 0 or len(psi_y) == 0: return np.array([]), np.array([])
    n_points = min(len(psi_x), len(psi_y) - 1)
    if n_points <= 0: return np.array([]), np.array([])
    psi_x_sliced, psi_y_sliced, psi_y_next_sliced = psi_x[:n_points], psi_y[:n_points], psi_y[1:n_points + 1]
    omega, amplitude = np.zeros(n_points), np.zeros(n_points)
    denom = 4 * psi_x_sliced
    safe_denom_mask = np.abs(denom) > 1e-10
    arg = np.ones(n_points)
    arg[safe_denom_mask] = 1 - (psi_y_sliced[safe_denom_mask] + psi_y_next_sliced[safe_denom_mask]) / denom[safe_denom_mask]
    omega = np.arccos(np.clip(arg, -1, 1))
    sin_omega = np.sin(omega)
    safe_sin_mask = np.abs(sin_omega) > 1e-10
    safe_mask = safe_denom_mask & safe_sin_mask
    if np.any(safe_mask):
      amplitude[safe_mask] = np.sqrt(np.abs(psi_x_sliced[safe_mask] / (sin_omega[safe_mask]**2)))
    if len(omega) > 5:
        omega = medfilt(omega, kernel_size=5)
        amplitude = medfilt(amplitude, kernel_size=5)
    return amplitude, omega

# --- STAGE 1: RAW VS. STANDARDIZED ---
plt.figure(figsize=(12, 4))
plt.suptitle('Stage 1: Raw vs. Standardized Signal (for Channel 1)', fontsize=16)
raw_channel_1 = multi_channel_signal[0, :]
time = np.arange(len(raw_channel_1)) / sampling_freq
if np.std(raw_channel_1) > 0:
    standardized_channel_1 = (raw_channel_1 - np.mean(raw_channel_1)) / np.std(raw_channel_1)
else:
    standardized_channel_1 = raw_channel_1
plt.subplot(1, 2, 1)
plt.plot(time, raw_channel_1, label='Raw')
plt.title('Before: Raw EEG Signal')
plt.xlabel('Time (s)'), plt.ylabel('Amplitude (µV)'), plt.legend()
plt.subplot(1, 2, 2)
plt.plot(time, standardized_channel_1, label='Standardized', color='orange')
plt.title('After: Standardized Signal')
plt.xlabel('Time (s)'), plt.ylabel('Standardized Value'), plt.legend()
plt.tight_layout(rect=[0, 0, 1, 0.96]), plt.show()

# --- STAGE 2: WAVELET DECOMPOSITION ---
wavelet = 'db6'
level = 5
coeffs = pywt.wavedec(standardized_channel_1, wavelet, level=level)
plt.figure(figsize=(12, 8))
plt.suptitle('Stage 2: Wavelet Decomposition (for Channel 1)', fontsize=16)
plt.subplot(level + 2, 1, 1)
plt.plot(standardized_channel_1, color='orange'), plt.title('Before: Standardized Signal')
for i, c in enumerate(coeffs):
    plt.subplot(level + 2, 1, i + 2)
    plt.plot(c, color='green' if i == 0 else 'red')
    plt.title(f'After: {"Approximation" if i == 0 else "Detail"} Coeffs ({("A" if i == 0 else "D") + str(level - i if i > 0 else level)})')
plt.tight_layout(rect=[0, 0, 1, 0.96]), plt.show()

# --- STAGE 2.5: DESA PROCESSING (for one level) ---
# Let's take one detail level (D3) and see what DESA does to it.
d3_coeffs = coeffs[3]
amplitude, frequency = _desa_algorithm(d3_coeffs)
plt.figure(figsize=(12, 6))
plt.suptitle('Stage 2.5: Applying DESA to Detail Coeffs (D3)', fontsize=16)
plt.subplot(3, 1, 1)
plt.plot(d3_coeffs, label='Input: D3 Coeffs', color='red'), plt.title('Before: Detail Coefficient Signal'), plt.legend()
plt.subplot(3, 1, 2)
plt.plot(amplitude, label='Output: Envelope (Amplitude)', color='blue'), plt.title('After (Output 1): Instantaneous Envelope - "How Strong"'), plt.legend()
plt.subplot(3, 1, 3)
plt.plot(frequency, label='Output: Frequency (Omega)', color='purple'), plt.title('After (Output 2): Instantaneous Frequency - "How Fast"')
plt.xlabel('Coefficient Index'), plt.legend()
plt.tight_layout(rect=[0, 0, 1, 0.96]), plt.show()

# --- STAGE 3: SPATIAL AVERAGING ---
list_of_feature_sets = []
num_channels_to_process = 4
for i in range(num_channels_to_process):
    channel_data = multi_channel_signal[i, :]
    if np.std(channel_data) > 0:
        channel_data = (channel_data - np.mean(channel_data)) / np.std(channel_data)
    c = pywt.wavedec(channel_data, wavelet, level=level)
    feature_set = [np.mean(np.abs(d)) for d in c]
    list_of_feature_sets.append(feature_set)
feature_table = np.array(list_of_feature_sets)
avg_features = np.mean(feature_table, axis=0)
plt.figure(figsize=(14, 8))
plt.title('Stage 3: Individual Channel Features vs. Spatially Averaged "avg_features"', fontsize=16)
feature_indices = np.arange(len(avg_features))
for i in range(num_channels_to_process):
    plt.plot(feature_indices, feature_table[i, :], marker='o', linestyle='--', label=f'Channel {i+1} Features', alpha=0.7)
plt.plot(feature_indices, avg_features, marker='D', linestyle='-', color='black', linewidth=3, markersize=8, label='After: Spatially Averaged (avg_features)')
plt.xlabel('Feature Index (from Wavelet Levels)', fontsize=12)
plt.ylabel('Calculated Feature Value', fontsize=12)
plt.xticks(feature_indices, [f'A{level}'] + [f'D{level-j}' for j in range(level)])
plt.legend(), plt.grid(True, linestyle='--', alpha=0.6), plt.show()

def _load_mat_file(self, filepath: str, target_fs: int = 256) -> Tuple[np.ndarray, int]:
      try:
        print(f"--> Attempting to load: {os.path.basename(filepath)}")
        mat_data = sio.loadmat(filepath)
      except Exception as e:
        print(f"Error loading {filepath}: {e}")
        return filepath,None,None
      segment_key = None
      for key in mat_data.keys():
        if 'segment' in key and not key.startswith('_'):
          segment_key = key
          break
        if segment_key is None:
          return None , None
        # Fast normalization
        data = np.nan_to_num(data, nan=0.0, posinf=1e6, neginf=-1e6)


        segment = mat_data[segment_key]
        data = segment['data'][0, 0].astype(np.float32)  # Use float32 for ME (memory efficient)
        original_fs = int(segment['sampling_frequency'][0, 0][0, 0])
        # Downsample if needed
        '''
        What does this do?
          Suppose you have a signal with a sampling frequency (sampling_freq) of 5000 Hz,
          and you want to downsample it to target_fs of 256 Hz.
          data.shape[1] = number of time samples in your original data
          (target_fs / sampling_freq) = proportion by which you want to shrink the signal
        Why multiply?
          If your signal is 5000 samples per second and you want 256 samples per second,
          For every 1 second (5000 samples), you want to keep only 256.
          The ratio is 256/5000 = 0.0512
          So, for any signal of length N, you want the new number of samples to be N * 0.0512
        Why int()?
          The result might not be an integer (e.g., 1250.4 samples).
          You need an integer number of samples, so you cast it to int.
          '''
        if original_fs > target_fs:
          num_samples = int(data.shape[1] * (target_fs / original_fs))
          data = resample(data, num_samples, axis=1)
          current_fs = target_fs
        else:
            current_fs = original_fs
        '''
        Why This Doesn’t Ruin the Data
             Relative changes and patterns (oscillations, spikes, seizures, etc.) in the EEG are preserved—these are what features and classifiers rely on.
             Differences in baseline between electrodes (maybe due to bad contact, scalp differences, sweat, etc.) are removed, which is a good thing.
             Differences in amplitude (e.g., one electrode picking up larger signals due to placement) are also normalized, so no channel “overpowers” the others just due to scaling.

        Why Do It?
            Prevents “big” channels from dominating machine learning.
            Removes arbitrary DC offset (baseline drift).
            Makes features like power, envelope, etc. directly comparable across channels and patients.
            Enables robust patient-aware feature extraction, as in the paper.
            '''

        # Fast preprocessing Normalize and Standardize (Check Example) CHECKLECTUREONTHEMATTER
        # Each channel has zero mean (removes DC offset or baseline drift).
        data = data - np.mean(data, axis=1, keepdims=True)
        #For each channel, computes the standard deviation of its signal (measures amplitude variation) . keepdims=True keeps the array shape compatible for division.
        channel_stds = np.std(data, axis=1, keepdims=True)
        #For any channel with “almost zero” variation (standard deviation < 1e-6), set the std to 1.0 (so you don’t divide by zero or a tiny number and get crazy values).
        channel_stds[channel_stds < 1e-6] = 1.0
        # Each channel now has zero mean and unit standard deviation (amplitude normalized).
        data = data / channel_stds

        return data, current_fs